import asyncio
import logging
import os
import time
import random
from fastapi import FastAPI, Request, HTTPException
from fastapi.responses import PlainTextResponse
from aiogram import Bot, Dispatcher, types
from aiogram.types import Update, Message, InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.filters import CommandStart
import httpx

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# 1. Ğ˜ĞœĞŸĞĞ Ğ¢Ğ« Ğ˜ ĞĞĞ¡Ğ¢Ğ ĞĞ™ĞšĞ˜
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

TOKEN = os.getenv("TOKEN")
if not TOKEN:
    raise ValueError("TOKEN Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½ Ğ² Environment Variables Render!")

BASE_URL = os.getenv("RENDER_EXTERNAL_URL")
WEBHOOK_PATH = f"/bot/{TOKEN}"
WEBHOOK_URL = f"{BASE_URL}{WEBHOOK_PATH}" if BASE_URL else None

logging.basicConfig(level=logging.INFO)
logging.info(f"Ğ‘Ğ¾Ñ‚ Ğ·Ğ°Ğ¿ÑƒÑ‰ĞµĞ½. TOKEN: {TOKEN[:10]}... BASE_URL: {BASE_URL}")

bot = Bot(token=TOKEN)
dp = Dispatcher()
app = FastAPI(title="Forest Survival Bot")

last_request_time = {}  # Ğ´Ğ»Ñ ĞºÑƒĞ»Ğ´Ğ°ÑƒĞ½Ğ°

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# 2. SELF-PING
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

PING_INTERVAL_SECONDS = 300

async def self_ping_task():
    if not BASE_URL:
        logging.info("Self-ping Ğ¾Ñ‚ĞºĞ»ÑÑ‡Ñ‘Ğ½")
        return
    ping_url = f"{BASE_URL}/ping"
    logging.info(f"Self-ping Ğ·Ğ°Ğ¿ÑƒÑ‰ĞµĞ½ (ĞºĞ°Ğ¶Ğ´Ñ‹Ğµ 5 Ğ¼Ğ¸Ğ½ â†’ {ping_url})")
    while True:
        try:
            async with httpx.AsyncClient() as client:
                r = await client.get(ping_url, timeout=10)
                if r.status_code == 200:
                    logging.info(f"[SELF-PING] OK â†’ {time.strftime('%Y-%m-%d %H:%M:%S')}")
        except Exception as e:
            logging.error(f"[SELF-PING] Ğ¾ÑˆĞ¸Ğ±ĞºĞ°: {e}")
        await asyncio.sleep(PING_INTERVAL_SECONDS)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# 3. ĞšĞ›ĞĞ¡Ğ¡ Ğ˜Ğ“Ğ Ğ«
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class Game:
    def __init__(self):
        self.hp = 100
        self.hunger = 30
        self.thirst = 30
        self.ap = 5
        self.karma = 0
        self.log = ["ğŸŒ² Ğ¢Ñ‹ Ğ¿Ñ€Ğ¾ÑĞ½ÑƒĞ»ÑÑ Ğ² Ğ»ĞµÑÑƒ. Ğ§Ñ‚Ğ¾ Ğ±ÑƒĞ´ĞµÑˆÑŒ Ğ´ĞµĞ»Ğ°Ñ‚ÑŒ?"]
        self.inventory = ["Ğ¡Ğ¿Ğ¸Ñ‡ĞºĞ¸ ğŸ”¥", "Ğ’Ğ¸Ğ»ĞºĞ° ğŸ´", "ĞšÑƒÑĞ¾Ğº ĞºĞ¾Ñ€Ñ‹ ğŸªµ"]

    def add_log(self, text):
        self.log.append(text)
        if len(self.log) > 15:
            self.log = self.log[-15:]

    def get_ui(self):
        return (
            f"â¤ï¸ HP: {self.hp}   ğŸ– Ğ“Ğ¾Ğ»Ğ¾Ğ´: {self.hunger}   ğŸ’§ Ğ–Ğ°Ğ¶Ğ´Ğ°: {self.thirst}\n"
            f"âš¡ ĞÑ‡ĞºĞ¸ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğ¹: {self.ap}   âš–ï¸ ĞšĞ°Ñ€Ğ¼Ğ°: {self.karma}\n"
            "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
            + "\n".join(f"> {line}" for line in self.log) + "\n"
            + "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        )

    def get_inventory_text(self):
        return "ğŸ’ Ğ˜Ğ½Ğ²ĞµĞ½Ñ‚Ğ°Ñ€ÑŒ:\n" + "\n".join(f"â€¢ {item}" for item in self.inventory) if self.inventory else "ğŸ’ Ğ˜Ğ½Ğ²ĞµĞ½Ñ‚Ğ°Ñ€ÑŒ Ğ¿ÑƒÑÑ‚"

games = {}
last_ui_msg_id = {}  # user_id â†’ message_id ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ñ Ğ¸Ğ³Ñ€Ñ‹

# ĞÑĞ½Ğ¾Ğ²Ğ½Ñ‹Ğµ inline-ĞºĞ½Ğ¾Ğ¿ĞºĞ¸ (Ğ¿Ğ¾Ğ´ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸ĞµĞ¼ Ğ¸Ğ³Ñ€Ñ‹)
main_inline_kb = InlineKeyboardMarkup(inline_keyboard=[
    [
        InlineKeyboardButton(text="1 Ğ’ Ñ‡Ğ°Ñ‰Ñƒ ğŸŒ²", callback_data="action_1"),
        InlineKeyboardButton(text="2 Ğ˜Ğ½Ğ²ĞµĞ½Ñ‚Ğ°Ñ€ÑŒ ğŸ’", callback_data="action_2"),
    ],
    [
        InlineKeyboardButton(text="3 ĞŸĞ¸Ñ‚ÑŒ Ğ²Ğ¾Ğ´Ñƒ ğŸ’§", callback_data="action_3"),
        InlineKeyboardButton(text="4 Ğ¡Ğ¿Ğ°Ñ‚ÑŒ ğŸŒ™", callback_data="action_4"),
    ],
    [
        InlineKeyboardButton(text="5 ĞŸĞ¾Ğ·Ğ²Ğ°Ñ‚ÑŒ Ğ¼ÑƒĞ´Ñ€ĞµÑ†Ğ° ğŸ§™", callback_data="action_5"),
        InlineKeyboardButton(text="6 Ğ¡Ğ±ĞµĞ¶Ğ°Ñ‚ÑŒ ğŸš", callback_data="action_6"),
    ],
])

# Inline-ĞºĞ½Ğ¾Ğ¿ĞºĞ¸ Ğ´Ğ»Ñ Ğ¸Ğ½Ğ²ĞµĞ½Ñ‚Ğ°Ñ€Ñ (Ğ¾Ñ‚Ğ´ĞµĞ»ÑŒĞ½Ğ¾Ğµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ)
inventory_inline_kb = InlineKeyboardMarkup(inline_keyboard=[
    [
        InlineKeyboardButton(text="ĞÑĞ¼Ğ¾Ñ‚Ñ€ĞµÑ‚ÑŒ ğŸ‘ï¸", callback_data="inv_inspect"),
        InlineKeyboardButton(text="Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ ğŸ› ï¸", callback_data="inv_use"),
        InlineKeyboardButton(text="Ğ’Ñ‹ĞºĞ¸Ğ½ÑƒÑ‚ÑŒ ğŸ—‘ï¸", callback_data="inv_drop"),
    ],
    [
        InlineKeyboardButton(text="ĞĞ°Ğ·Ğ°Ğ´ â†", callback_data="inv_back"),
    ],
])

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# 4. Ğ¥Ğ•ĞĞ”Ğ›Ğ•Ğ Ğ«
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

@dp.message(CommandStart())
async def cmd_start(message: Message):
    uid = message.from_user.id

    # ĞÑ‡Ğ¸ÑÑ‚ĞºĞ° Ğ¿Ñ€ĞµĞ´Ñ‹Ğ´ÑƒÑ‰Ğ¸Ñ… ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğ¹ Ğ±Ğ¾Ñ‚Ğ°
    try:
        history = await bot.get_chat_history(message.chat.id, limit=30)
        for msg in history:
            if msg.from_user and msg.from_user.id == (await bot.get_me()).id:
                if msg.message_id != message.message_id:
                    await bot.delete_message(message.chat.id, msg.message_id)
    except Exception as e:
        logging.warning(f"ĞÑ‡Ğ¸ÑÑ‚ĞºĞ° Ñ‡Ğ°Ñ‚Ğ° Ğ½Ğµ ÑƒĞ´Ğ°Ğ»Ğ°ÑÑŒ: {e}")

    games[uid] = Game()

    await message.answer(
        "ğŸŒ² Ğ”Ğ¾Ğ±Ñ€Ğ¾ Ğ¿Ğ¾Ğ¶Ğ°Ğ»Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ² Ğ»ĞµÑ Ğ²Ñ‹Ğ¶Ğ¸Ğ²Ğ°Ğ½Ğ¸Ñ!\n\nĞ’Ñ‹Ğ±ĞµÑ€Ğ¸ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ Ğ½Ğ¸Ğ¶Ğµ â†“"
    )

    ui_msg = await message.answer(games[uid].get_ui(), reply_markup=main_inline_kb)
    last_ui_msg_id[uid] = ui_msg.message_id

@dp.callback_query()
async def process_callback(callback: types.CallbackQuery):
    uid = callback.from_user.id
    now = time.time()

    # ĞšÑƒĞ»Ğ´Ğ°ÑƒĞ½ 1 ÑĞµĞºÑƒĞ½Ğ´Ğ°
    if uid in last_request_time and now - last_request_time[uid] < 1.0:
        await callback.answer("ĞŸĞ¾Ğ´Ğ¾Ğ¶Ğ´Ğ¸ ÑĞµĞºÑƒĞ½Ğ´Ñƒ!")
        return
    last_request_time[uid] = now

    if uid not in games:
        await callback.message.answer("Ğ¡Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ° /start")
        await callback.answer()
        return

    game = games[uid]
    data = callback.data
    action_taken = False

    if data == "action_1":
        if game.ap > 0:
            game.ap -= 1
            game.add_log("ğŸ” Ğ¢Ñ‹ Ğ¿Ğ¾ÑˆÑ‘Ğ» Ğ² Ñ‡Ğ°Ñ‰Ñƒ... Ğ½Ğ°ÑˆÑ‘Ğ» ĞºĞ¾Ñ€Ñƒ!")
            action_taken = True
        else:
            game.add_log("âŒ Ğ¢Ñ‹ ÑĞ»Ğ¸ÑˆĞºĞ¾Ğ¼ ÑƒÑÑ‚Ğ°Ğ»!")
            action_taken = True
    elif data == "action_2":
        inv_msg = await callback.message.answer(game.get_inventory_text(), reply_markup=inventory_inline_kb)
        # ĞœĞ¾Ğ¶Ğ½Ğ¾ ÑĞ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ id ÑÑ‚Ğ¾Ğ³Ğ¾ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ, ĞµÑĞ»Ğ¸ Ñ…Ğ¾Ñ‡ĞµÑˆÑŒ Ğ¿Ğ¾Ñ‚Ğ¾Ğ¼ Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ
        await callback.answer()
        return
    elif data == "action_3":
        game.add_log("ğŸ’§ ĞĞ°Ğ¿Ğ¸Ğ»ÑÑ... Ğ¶Ğ°Ğ¶Ğ´Ğ° -20")
        game.thirst = max(0, game.thirst - 20)
        action_taken = True
    elif data == "action_4":
        game.add_log("ğŸŒ™ ĞŸĞ¾ÑĞ¿Ğ°Ğ»... Ğ²Ğ¾ÑÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ğ» Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ñ, Ğ³Ğ¾Ğ»Ğ¾Ğ´ +15")
        game.ap = 5
        game.hunger += 15
        action_taken = True
    elif data == "action_5":
        game.add_log("ğŸ§™ ĞœÑƒĞ´Ñ€ĞµÑ† Ğ´Ğ°Ğ» ÑĞ¾Ğ²ĞµÑ‚... +5 ĞºĞ°Ñ€Ğ¼Ñ‹")
        game.karma += 5
        action_taken = True
    elif data == "action_6":
        chance = 10 + (game.karma // 10)
        if random.randint(1, 100) <= chance:
            await callback.message.answer(
                "ğŸš ĞŸĞĞ‘Ğ•Ğ”Ğ! Ğ¢Ñ‹ ÑĞ±ĞµĞ¶Ğ°Ğ» Ğ¸Ğ· Ğ»ĞµÑĞ°!\n\nĞĞ°Ğ¿Ğ¸ÑˆĞ¸ /start Ğ´Ğ»Ñ Ğ½Ğ¾Ğ²Ğ¾Ğ¹ Ğ¸Ğ³Ñ€Ñ‹."
            )
            games.pop(uid, None)
            last_ui_msg_id.pop(uid, None)
            await callback.answer("ĞŸĞ¾Ğ±ĞµĞ´Ğ°!")
            return
        else:
            game.add_log("ĞŸĞ¾Ğ±ĞµĞ³ Ğ½Ğµ ÑƒĞ´Ğ°Ğ»ÑÑ... Ğ¾ÑÑ‚Ğ°Ñ‘Ğ¼ÑÑ Ğ² Ğ»ĞµÑÑƒ")
            action_taken = True
    elif data == "inv_inspect":
        game.add_log("ĞÑĞ¼Ğ¾Ñ‚Ñ€ĞµĞ» Ğ¸Ğ½Ğ²ĞµĞ½Ñ‚Ğ°Ñ€ÑŒ... Ğ½Ğ¸Ñ‡ĞµĞ³Ğ¾ Ğ¸Ğ½Ñ‚ĞµÑ€ĞµÑĞ½Ğ¾Ğ³Ğ¾ (Ğ·Ğ°Ğ³Ğ»ÑƒÑˆĞºĞ°)")
        action_taken = True
    elif data == "inv_use":
        game.add_log("Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ» Ğ¿Ñ€ĞµĞ´Ğ¼ĞµÑ‚... ÑÑ„Ñ„ĞµĞºÑ‚ Ğ¿Ğ¾ĞºĞ° Ğ½Ğµ Ñ€ĞµĞ°Ğ»Ğ¸Ğ·Ğ¾Ğ²Ğ°Ğ½")
        action_taken = True
    elif data == "inv_drop":
        game.add_log("Ğ’Ñ‹ĞºĞ¸Ğ½ÑƒĞ» Ğ¿Ñ€ĞµĞ´Ğ¼ĞµÑ‚... Ğ¸Ğ½Ğ²ĞµĞ½Ñ‚Ğ°Ñ€ÑŒ ÑÑ‚Ğ°Ğ» Ğ»ĞµĞ³Ñ‡Ğµ (Ğ·Ğ°Ğ³Ğ»ÑƒÑˆĞºĞ°)")
        action_taken = True
    elif data == "inv_back":
        # Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµĞ¼ÑÑ Ğº Ğ¾ÑĞ½Ğ¾Ğ²Ğ½Ğ¾Ğ¼Ñƒ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ñ
        await callback.message.edit_text(game.get_ui(), reply_markup=main_inline_kb)
        await callback.answer()
        return

    if action_taken:
        await callback.message.edit_text(
            game.get_ui(),
            reply_markup=main_inline_kb
        )
        await callback.answer()

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# 5. FASTAPI ĞœĞĞ Ğ¨Ğ Ğ£Ğ¢Ğ« Ğ˜ Ğ–Ğ˜Ğ—ĞĞ•ĞĞĞ«Ğ™ Ğ¦Ğ˜ĞšĞ›
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

@app.get("/ping")
@app.get("/health")
async def health_check():
    return PlainTextResponse("OK", status_code=200)

@app.post(WEBHOOK_PATH)
async def webhook(request: Request):
    try:
        body = await request.json()
        update = Update.model_validate(body, context={"bot": bot})
        await dp.feed_update(bot, update)
        return {"ok": True}
    except Exception as e:
        logging.error(f"Webhook error: {e}")
        raise HTTPException(status_code=500)

@app.on_event("startup")
async def on_startup():
    if WEBHOOK_URL:
        try:
            await bot.delete_webhook(drop_pending_updates=True)
        except:
            pass
        try:
            await bot.set_webhook(WEBHOOK_URL)
            logging.info(f"Webhook ÑƒÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½: {WEBHOOK_URL}")
        except Exception as e:
            logging.error(f"set_webhook failed: {e}")
    asyncio.create_task(self_ping_task())

@app.on_event("shutdown")
async def on_shutdown():
    try:
        await bot.delete_webhook(drop_pending_updates=True)
    except:
        pass

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)